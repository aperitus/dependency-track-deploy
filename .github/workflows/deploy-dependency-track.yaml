name: Deploy Dependency-Track (AKS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: GitHub Environment to use
        required: true
        type: choice
        options:
          - dev
          - preprod
          - prod

      use_admin_credentials:
        description: Use AKS admin kubeconfig (adds --admin to az aks get-credentials)
        required: false
        type: boolean
        default: false

      helm_timeout:
        description: Helm timeout (optional; defaults to 15m)
        required: false
        type: string
        default: "15m"

concurrency:
  group: dependency-track-deploy-${{ inputs.environment }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  deploy:
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 30

    env:
      # Keep Azure CLI state isolated and avoid cross-job contamination.
      AZURE_CONFIG_DIR: $RUNNER_TEMP/.azure
      KUBECONFIG: $RUNNER_TEMP/kubeconfig

      # Helm timeout (validated/normalised in a step below)
      HELM_TIMEOUT: ${{ inputs.helm_timeout }}

      # ----------------------------------------------------------------------
      # Vars-first fallback to secrets (no resolver script)
      # ----------------------------------------------------------------------

      # Azure / AKS
      DEPLOY_CLIENT_ID: ${{ vars.DEPLOY_CLIENT_ID != '' && vars.DEPLOY_CLIENT_ID || secrets.DEPLOY_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID != '' && vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID != '' && vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_SECRET: ${{ vars.DEPLOY_SECRET != '' && vars.DEPLOY_SECRET || secrets.DEPLOY_SECRET }}
      AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP != '' && vars.AKS_RESOURCE_GROUP || secrets.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME != '' && vars.AKS_CLUSTER_NAME || secrets.AKS_CLUSTER_NAME }}

      # Container registry creds (Nexus)
      REGISTRY_SERVER: ${{ vars.REGISTRY_SERVER != '' && vars.REGISTRY_SERVER || secrets.REGISTRY_SERVER }}
      REGISTRY_USERNAME: ${{ vars.REGISTRY_USERNAME != '' && vars.REGISTRY_USERNAME || secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ vars.REGISTRY_PASSWORD != '' && vars.REGISTRY_PASSWORD || secrets.REGISTRY_PASSWORD }}

      # Wildcard TLS material
      WILDCARD_CRT: ${{ vars.WILDCARD_CRT != '' && vars.WILDCARD_CRT || secrets.WILDCARD_CRT }}
      WILDCARD_KEY: ${{ vars.WILDCARD_KEY != '' && vars.WILDCARD_KEY || secrets.WILDCARD_KEY }}

      # Database (external Postgres)
      # Preferred: set ALPINE_DATABASE_URL/USERNAME/PASSWORD directly.
      # Legacy fallback: DTRACK_DB_URL (used only if ALPINE_DATABASE_URL is empty).
      DTRACK_DB_URL: ${{ vars.DTRACK_DB_URL != '' && vars.DTRACK_DB_URL || secrets.DTRACK_DB_URL }}
      ALPINE_DATABASE_MODE: ${{ (vars.ALPINE_DATABASE_MODE != '' && vars.ALPINE_DATABASE_MODE) || (secrets.ALPINE_DATABASE_MODE != '' && secrets.ALPINE_DATABASE_MODE) || '' }}
      ALPINE_DATABASE_URL: ${{ (vars.ALPINE_DATABASE_URL != '' && vars.ALPINE_DATABASE_URL) || (secrets.ALPINE_DATABASE_URL != '' && secrets.ALPINE_DATABASE_URL) || '' }}
      ALPINE_DATABASE_USERNAME: ${{ (vars.ALPINE_DATABASE_USERNAME != '' && vars.ALPINE_DATABASE_USERNAME) || (secrets.ALPINE_DATABASE_USERNAME != '' && secrets.ALPINE_DATABASE_USERNAME) || '' }}
      ALPINE_DATABASE_PASSWORD: ${{ (vars.ALPINE_DATABASE_PASSWORD != '' && vars.ALPINE_DATABASE_PASSWORD) || (secrets.ALPINE_DATABASE_PASSWORD != '' && secrets.ALPINE_DATABASE_PASSWORD) || '' }}

      # Defaults (can be overridden via vars/secrets)
      DTRACK_NAMESPACE: ${{ (vars.DTRACK_NAMESPACE != '' && vars.DTRACK_NAMESPACE) || (secrets.DTRACK_NAMESPACE != '' && secrets.DTRACK_NAMESPACE) || 'dependency-track' }}
      DTRACK_RELEASE_NAME: ${{ (vars.DTRACK_RELEASE_NAME != '' && vars.DTRACK_RELEASE_NAME) || (secrets.DTRACK_RELEASE_NAME != '' && secrets.DTRACK_RELEASE_NAME) || 'dependency-track' }}
      DTRACK_INGRESS_HOST: ${{ (vars.DTRACK_INGRESS_HOST != '' && vars.DTRACK_INGRESS_HOST) || (secrets.DTRACK_INGRESS_HOST != '' && secrets.DTRACK_INGRESS_HOST) || 'dtrack.logiki.co.uk' }}
      DTRACK_INGRESS_CLASS_NAME: ${{ (vars.DTRACK_INGRESS_CLASS_NAME != '' && vars.DTRACK_INGRESS_CLASS_NAME) || (secrets.DTRACK_INGRESS_CLASS_NAME != '' && secrets.DTRACK_INGRESS_CLASS_NAME) || 'traefik' }}

      # Helm chart
      DTRACK_HELM_REPO_URL: ${{ (vars.DTRACK_HELM_REPO_URL != '' && vars.DTRACK_HELM_REPO_URL) || (secrets.DTRACK_HELM_REPO_URL != '' && secrets.DTRACK_HELM_REPO_URL) || 'https://dependencytrack.github.io/helm-charts' }}
      DTRACK_CHART_VERSION: ${{ (vars.DTRACK_CHART_VERSION != '' && vars.DTRACK_CHART_VERSION) || (secrets.DTRACK_CHART_VERSION != '' && secrets.DTRACK_CHART_VERSION) || '0.41.0' }}

      # K8s secret names
      IMAGE_PULL_SECRET_NAME: ${{ (vars.IMAGE_PULL_SECRET_NAME != '' && vars.IMAGE_PULL_SECRET_NAME) || (secrets.IMAGE_PULL_SECRET_NAME != '' && secrets.IMAGE_PULL_SECRET_NAME) || 'nexus-pull' }}
      INGRESS_TLS_SECRET_NAME: ${{ (vars.INGRESS_TLS_SECRET_NAME != '' && vars.INGRESS_TLS_SECRET_NAME) || (secrets.INGRESS_TLS_SECRET_NAME != '' && secrets.INGRESS_TLS_SECRET_NAME) || 'dtrack-wildcard-tls' }}
      DTRACK_APP_CONFIG_SECRET_NAME: ${{ (vars.DTRACK_APP_CONFIG_SECRET_NAME != '' && vars.DTRACK_APP_CONFIG_SECRET_NAME) || (secrets.DTRACK_APP_CONFIG_SECRET_NAME != '' && secrets.DTRACK_APP_CONFIG_SECRET_NAME) || 'dependency-track-app-config' }}

      # Images (always pulled from REGISTRY_SERVER)
      DTRACK_APISERVER_IMAGE_REPOSITORY: ${{ (vars.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && vars.DTRACK_APISERVER_IMAGE_REPOSITORY) || (secrets.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && secrets.DTRACK_APISERVER_IMAGE_REPOSITORY) || 'dependencytrack/apiserver' }}
      DTRACK_FRONTEND_IMAGE_REPOSITORY: ${{ (vars.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && vars.DTRACK_FRONTEND_IMAGE_REPOSITORY) || (secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY) || 'dependencytrack/frontend' }}
      DTRACK_APISERVER_IMAGE_TAG: ${{ (vars.DTRACK_APISERVER_IMAGE_TAG != '' && vars.DTRACK_APISERVER_IMAGE_TAG) || (secrets.DTRACK_APISERVER_IMAGE_TAG != '' && secrets.DTRACK_APISERVER_IMAGE_TAG) || '' }}
      DTRACK_FRONTEND_IMAGE_TAG: ${{ (vars.DTRACK_FRONTEND_IMAGE_TAG != '' && vars.DTRACK_FRONTEND_IMAGE_TAG) || (secrets.DTRACK_FRONTEND_IMAGE_TAG != '' && secrets.DTRACK_FRONTEND_IMAGE_TAG) || '' }}

      # Optional
      DTRACK_FRONTEND_API_BASE_URL: ${{ (vars.DTRACK_FRONTEND_API_BASE_URL != '' && vars.DTRACK_FRONTEND_API_BASE_URL) || (secrets.DTRACK_FRONTEND_API_BASE_URL != '' && secrets.DTRACK_FRONTEND_API_BASE_URL) || '' }}
      DTRACK_SECRET_KEY_CREATE: ${{ (vars.DTRACK_SECRET_KEY_CREATE != '' && vars.DTRACK_SECRET_KEY_CREATE) || (secrets.DTRACK_SECRET_KEY_CREATE != '' && secrets.DTRACK_SECRET_KEY_CREATE) || 'true' }}
      DTRACK_SECRET_KEY_EXISTING_SECRET_NAME: ${{ (vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || (secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || '' }}
      DTRACK_INGRESS_ANNOTATIONS_JSON: ${{ (vars.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && vars.DTRACK_INGRESS_ANNOTATIONS_JSON) || (secrets.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && secrets.DTRACK_INGRESS_ANNOTATIONS_JSON) || '{}' }}

      # PV placeholders (explicit defaults)
      DTRACK_APISERVER_PV_ENABLED: ${{ (vars.DTRACK_APISERVER_PV_ENABLED != '' && vars.DTRACK_APISERVER_PV_ENABLED) || (secrets.DTRACK_APISERVER_PV_ENABLED != '' && secrets.DTRACK_APISERVER_PV_ENABLED) || 'false' }}
      DTRACK_APISERVER_PV_CLASSNAME: ${{ (vars.DTRACK_APISERVER_PV_CLASSNAME != '' && vars.DTRACK_APISERVER_PV_CLASSNAME) || (secrets.DTRACK_APISERVER_PV_CLASSNAME != '' && secrets.DTRACK_APISERVER_PV_CLASSNAME) || '' }}
      DTRACK_APISERVER_PV_SIZE: ${{ (vars.DTRACK_APISERVER_PV_SIZE != '' && vars.DTRACK_APISERVER_PV_SIZE) || (secrets.DTRACK_APISERVER_PV_SIZE != '' && secrets.DTRACK_APISERVER_PV_SIZE) || '5Gi' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalise runner temp paths
        shell: bash
        run: |
          set -euo pipefail
          # Job-level env uses literal $RUNNER_TEMP; normalise to resolved paths for tooling.
          echo "AZURE_CONFIG_DIR=${RUNNER_TEMP}/.azure" >> "${GITHUB_ENV}"
          echo "KUBECONFIG=${RUNNER_TEMP}/kubeconfig" >> "${GITHUB_ENV}"

      # ----------------------------------------------------------------------
      # Reused patterns from deploy-traefik.yaml (tested on your runner)
      # ----------------------------------------------------------------------

      - name: Verify toolchain on runner
        shell: bash
        run: |
          set -euo pipefail
          command -v az >/dev/null
          command -v kubectl >/dev/null
          command -v helm >/dev/null
          command -v python3 >/dev/null
          command -v kubelogin >/dev/null
          command -v openssl >/dev/null
          az version
          kubectl version --client=true
          helm version
          kubelogin --version || true

      - name: Echo resolved inputs (masked if sourced from secrets)
        shell: bash
        run: |
          set -euo pipefail
          echo "DEPLOY_CLIENT_ID=${DEPLOY_CLIENT_ID}"
          echo "AZURE_TENANT_ID=${AZURE_TENANT_ID}"
          echo "AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
          echo "AKS_RESOURCE_GROUP=${AKS_RESOURCE_GROUP}"
          echo "AKS_CLUSTER_NAME=${AKS_CLUSTER_NAME}"
          echo "REGISTRY_SERVER=${REGISTRY_SERVER}"
          echo "REGISTRY_USERNAME=${REGISTRY_USERNAME}"
          echo "IMAGE_PULL_SECRET_NAME=${IMAGE_PULL_SECRET_NAME}"
          echo "INGRESS_TLS_SECRET_NAME=${INGRESS_TLS_SECRET_NAME}"
          echo "DTRACK_NAMESPACE=${DTRACK_NAMESPACE}"
          echo "DTRACK_RELEASE_NAME=${DTRACK_RELEASE_NAME}"
          echo "DTRACK_INGRESS_HOST=${DTRACK_INGRESS_HOST}"
          echo "DTRACK_INGRESS_CLASS_NAME=${DTRACK_INGRESS_CLASS_NAME}"
          echo "DTRACK_HELM_REPO_URL=${DTRACK_HELM_REPO_URL}"
          echo "DTRACK_CHART_VERSION=${DTRACK_CHART_VERSION}"
          echo "DTRACK_APISERVER_IMAGE_REPOSITORY=${DTRACK_APISERVER_IMAGE_REPOSITORY}"
          echo "DTRACK_FRONTEND_IMAGE_REPOSITORY=${DTRACK_FRONTEND_IMAGE_REPOSITORY}"
          echo "ALPINE_DATABASE_MODE=${ALPINE_DATABASE_MODE}"
          # Avoid leaking credentials if a non-JDBC URL is accidentally provided via vars.
          if [[ -n "${ALPINE_DATABASE_URL:-}" && "${ALPINE_DATABASE_URL}" == jdbc:postgresql://* ]]; then
            echo "ALPINE_DATABASE_URL=${ALPINE_DATABASE_URL}"
          elif [[ -n "${ALPINE_DATABASE_URL:-}" ]]; then
            echo "ALPINE_DATABASE_URL=<non-jdbc: not printed>"
          else
            echo "ALPINE_DATABASE_URL="
          fi
          echo "ALPINE_DATABASE_USERNAME=${ALPINE_DATABASE_USERNAME}"
          echo "ALPINE_DATABASE_PASSWORD=<redacted>"

      - name: Azure login (Service Principal + secret)
        shell: bash
        run: |
          set -euo pipefail
          : "${DEPLOY_CLIENT_ID:?DEPLOY_CLIENT_ID empty}"
          : "${DEPLOY_SECRET:?DEPLOY_SECRET empty}"
          : "${AZURE_TENANT_ID:?AZURE_TENANT_ID empty}"
          : "${AZURE_SUBSCRIPTION_ID:?AZURE_SUBSCRIPTION_ID empty}"

          # Force non-interactive Azure CLI behaviour by isolating config and clearing any stale context.
          # This ensures deterministic behaviour on long-lived self-hosted runners.
          rm -rf "${AZURE_CONFIG_DIR}" 2>/dev/null || true
          mkdir -p "${AZURE_CONFIG_DIR}"
          az logout --output=none 2>/dev/null || true
          az account clear --output=none 2>/dev/null || true

          az login \
            --service-principal \
            --username="${DEPLOY_CLIENT_ID}" \
            --password="${DEPLOY_SECRET}" \
            --tenant="${AZURE_TENANT_ID}" \
            --output=none

          az account set --subscription="${AZURE_SUBSCRIPTION_ID}"

      - name: Validate required variables and normalise Helm timeout
        shell: bash
        run: |
          set -euo pipefail

          : "${AKS_RESOURCE_GROUP:?AKS_RESOURCE_GROUP empty}"
          : "${AKS_CLUSTER_NAME:?AKS_CLUSTER_NAME empty}"
          : "${DTRACK_CHART_VERSION:?DTRACK_CHART_VERSION empty}"
          : "${HELM_TIMEOUT:?HELM_TIMEOUT empty}"

          : "${REGISTRY_SERVER:?REGISTRY_SERVER empty}"
          : "${REGISTRY_USERNAME:?REGISTRY_USERNAME empty}"
          : "${REGISTRY_PASSWORD:?REGISTRY_PASSWORD empty}"
          : "${IMAGE_PULL_SECRET_NAME:?IMAGE_PULL_SECRET_NAME empty}"

          : "${INGRESS_TLS_SECRET_NAME:?INGRESS_TLS_SECRET_NAME empty}"
          : "${WILDCARD_CRT:?WILDCARD_CRT empty}"
          : "${WILDCARD_KEY:?WILDCARD_KEY empty}"

          # Database config (external Postgres)
          # Prefer ALPINE_DATABASE_* directly. DTRACK_DB_URL is legacy fallback.
          if [[ -z "${ALPINE_DATABASE_URL:-}" && -z "${DTRACK_DB_URL:-}" ]]; then
            echo "ERROR: Database URL is missing. Set ALPINE_DATABASE_URL (preferred) or DTRACK_DB_URL (legacy)." >&2
            exit 1
          fi
          : "${ALPINE_DATABASE_USERNAME:?ALPINE_DATABASE_USERNAME empty}"
          : "${ALPINE_DATABASE_PASSWORD:?ALPINE_DATABASE_PASSWORD empty}"

          if [[ -z "${ALPINE_DATABASE_MODE:-}" ]]; then
            echo "ALPINE_DATABASE_MODE=external" >> "${GITHUB_ENV}"
          fi

          # Normalise Helm timeout:
          # - If value is purely numeric (e.g. "10"), treat as minutes ("10m")
          # - If it already has a unit suffix (s/m/h), keep as-is
          if [[ "${HELM_TIMEOUT}" =~ ^[0-9]+$ ]]; then
            HELM_TIMEOUT="${HELM_TIMEOUT}m"
          fi
          if [[ ! "${HELM_TIMEOUT}" =~ ^[0-9]+[smh]$ ]]; then
            echo "ERROR: HELM_TIMEOUT must be like '10m', '600s', '5h' (or a number of minutes like '10'). Got: '${HELM_TIMEOUT}'" >&2
            exit 1
          fi
          echo "HELM_TIMEOUT=${HELM_TIMEOUT}" >> "${GITHUB_ENV}"

      - name: Get AKS credentials (Entra) + kubelogin convert
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ADMIN_FLAG=""
          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials \
            --resource-group="${AKS_RESOURCE_GROUP}" \
            --name="${AKS_CLUSTER_NAME}" \
            ${ADMIN_FLAG} \
            --file="${KUBECONFIG}" \
            --overwrite-existing

          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            echo "Using admin kubeconfig; skipping kubelogin convert."
            exit 0
          fi

          kubelogin convert-kubeconfig \
            --login="spn" \
            --client-id="${DEPLOY_CLIENT_ID}" \
            --client-secret="${DEPLOY_SECRET}" \
            --tenant-id="${AZURE_TENANT_ID}" \
            --kubeconfig="${KUBECONFIG}"

          if grep --quiet "command: azurecli" "${KUBECONFIG}"; then
            echo "ERROR: kubeconfig still references azurecli exec (interactive). kubelogin convert failed." >&2
            exit 1
          fi

      # ----------------------------------------------------------------------
      # Dependency-Track deployment
      # ----------------------------------------------------------------------

      - name: Ensure namespace
        shell: bash
        run: |
          set -euo pipefail
          kubectl get namespace "${DTRACK_NAMESPACE}" >/dev/null 2>&1 || kubectl create namespace "${DTRACK_NAMESPACE}"

      - name: Create/update imagePullSecret (registry) in dependency-track namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret docker-registry "${IMAGE_PULL_SECRET_NAME}" \
            --docker-server="${REGISTRY_SERVER}" \
            --docker-username="${REGISTRY_USERNAME}" \
            --docker-password="${REGISTRY_PASSWORD}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Create/update TLS secret (wildcard) in dependency-track namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          CERT_FILE="/tmp/wildcard.crt"
          KEY_FILE="/tmp/wildcard.key"
          export CERT_FILE KEY_FILE

          # Write PEM material to temp files without printing to logs.
          # Note: we normalise CRLF -> LF to avoid PEM parsing issues.
          python3 - <<'PY'
          import os
          from pathlib import Path

          crt = os.environ.get('WILDCARD_CRT','').replace('\r\n', '\n').replace('\r', '')
          key = os.environ.get('WILDCARD_KEY','').replace('\r\n', '\n').replace('\r', '')

          Path(os.environ['CERT_FILE']).write_text(crt, encoding='utf-8')
          Path(os.environ['KEY_FILE']).write_text(key, encoding='utf-8')
          PY

          chmod 600 "${CERT_FILE}" "${KEY_FILE}"

          if [[ ! -s "${CERT_FILE}" ]]; then
            echo "ERROR: Certificate file is empty after writing secrets. Check WILDCARD_CRT." >&2
            exit 1
          fi
          if [[ ! -s "${KEY_FILE}" ]]; then
            echo "ERROR: Key file is empty after writing secrets. Check WILDCARD_KEY." >&2
            exit 1
          fi

          # Patterns start with dashes; use `--` to prevent grep treating them as options.
          if ! grep -F -q -- "-----BEGIN CERTIFICATE-----" "${CERT_FILE}"; then
            echo "ERROR: WILDCARD_CRT does not look like PEM. Expected '-----BEGIN CERTIFICATE-----' header." >&2
            exit 1
          fi
          if ! grep -F -q -- "-----BEGIN" "${KEY_FILE}"; then
            echo "ERROR: WILDCARD_KEY does not look like PEM." >&2
            exit 1
          fi

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret tls "${INGRESS_TLS_SECRET_NAME}" \
            --cert="${CERT_FILE}" \
            --key="${KEY_FILE}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Create/update app config secret (dependency-track)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ENV_FILE="${RUNNER_TEMP}/dtrack.env"
          export ENV_FILE
          rm -f "${ENV_FILE}" || true
          : > "${ENV_FILE}"
          chmod 600 "${ENV_FILE}"

          # Write env file without echoing values to logs.
          python3 - <<'PY'
          import os
          from pathlib import Path
          from urllib.parse import urlparse, parse_qsl, urlencode

          env_file = Path(os.environ['ENV_FILE'])

          dtrack_db_url = os.environ.get('DTRACK_DB_URL','').strip()
          alpine_url = os.environ.get('ALPINE_DATABASE_URL','').strip()
          alpine_mode = os.environ.get('ALPINE_DATABASE_MODE','').strip()
          alpine_user = os.environ.get('ALPINE_DATABASE_USERNAME','').strip()
          alpine_pass = os.environ.get('ALPINE_DATABASE_PASSWORD','').strip()

          def to_jdbc(url: str) -> tuple[str, str, str]:
            """Return (jdbc_url, user, pass).

            Accepts:
              - jdbc:postgresql://host:port/db?sslmode=require
              - postgres://user:pass@host:port/db?sslmode=require
              - postgresql://user:pass@host:port/db
            """
            if url.startswith('jdbc:postgresql:'):
              return url, '', ''

            if url.startswith('postgres://') or url.startswith('postgresql://'):
              u = urlparse(url)
              host = u.hostname
              port = u.port or 5432
              db = (u.path or '').lstrip('/')
              if not host or not db:
                raise SystemExit('Database URL must include host and database name.')

              q = dict(parse_qsl(u.query, keep_blank_values=True))
              if 'sslmode' not in q:
                q['sslmode'] = 'require'
              query = urlencode(q)

              jdbc = f"jdbc:postgresql://{host}:{port}/{db}"
              if query:
                jdbc += f"?{query}"

              user = u.username or ''
              pw = u.password or ''
              return jdbc, user, pw

            raise SystemExit(
              "Database URL must be a JDBC URL (jdbc:postgresql://...) or a libpq URL (postgres://... or postgresql://...)."
            )

          # Prefer explicit ALPINE_DATABASE_URL; fall back to legacy DTRACK_DB_URL.
          source_url = alpine_url or dtrack_db_url
          jdbc_url, parsed_user, parsed_pass = to_jdbc(source_url)

          # If caller provided user/pass separately, keep them; otherwise use parsed credentials (if present).
          if not alpine_user and parsed_user:
            alpine_user = parsed_user
          if not alpine_pass and parsed_pass:
            alpine_pass = parsed_pass

          data = {
            'ALPINE_DATABASE_MODE': alpine_mode or 'external',
            'ALPINE_DATABASE_URL': jdbc_url,
            'ALPINE_DATABASE_USERNAME': alpine_user,
            'ALPINE_DATABASE_PASSWORD': alpine_pass,
          }

          missing = [k for k in ('ALPINE_DATABASE_URL','ALPINE_DATABASE_USERNAME','ALPINE_DATABASE_PASSWORD') if not data.get(k)]
          if missing:
            raise SystemExit(f"Missing required database keys for Dependency-Track: {', '.join(missing)}")

          env_file.write_text("\n".join([f"{k}={v}" for k, v in data.items()]) + "\n", encoding='utf-8')
          PY

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret generic "${DTRACK_APP_CONFIG_SECRET_NAME}" \
            --from-env-file="${ENV_FILE}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Render values.generated.yaml (no secret logging)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          python3 - <<'PY'
          import os, json
          from pathlib import Path

          repl = {
            '<REGISTRY_SERVER>': os.environ.get('REGISTRY_SERVER',''),
            '<IMAGE_PULL_SECRET_NAME>': os.environ.get('IMAGE_PULL_SECRET_NAME',''),

            '<DTRACK_SECRET_KEY_CREATE>': (os.environ.get('DTRACK_SECRET_KEY_CREATE','true') or 'true').lower(),
            '<DTRACK_SECRET_KEY_EXISTING_SECRET_NAME>': os.environ.get('DTRACK_SECRET_KEY_EXISTING_SECRET_NAME',''),

            '<DTRACK_APISERVER_IMAGE_REPOSITORY>': os.environ.get('DTRACK_APISERVER_IMAGE_REPOSITORY','dependencytrack/apiserver'),
            '<DTRACK_APISERVER_IMAGE_TAG>': os.environ.get('DTRACK_APISERVER_IMAGE_TAG',''),

            '<DTRACK_FRONTEND_IMAGE_REPOSITORY>': os.environ.get('DTRACK_FRONTEND_IMAGE_REPOSITORY','dependencytrack/frontend'),
            '<DTRACK_FRONTEND_IMAGE_TAG>': os.environ.get('DTRACK_FRONTEND_IMAGE_TAG',''),

            '<DTRACK_FRONTEND_API_BASE_URL>': os.environ.get('DTRACK_FRONTEND_API_BASE_URL',''),

            '<DTRACK_INGRESS_HOST>': os.environ.get('DTRACK_INGRESS_HOST','example.com'),
            '<DTRACK_INGRESS_CLASS_NAME>': os.environ.get('DTRACK_INGRESS_CLASS_NAME',''),
            '<INGRESS_TLS_SECRET_NAME>': os.environ.get('INGRESS_TLS_SECRET_NAME',''),

            '<DTRACK_APP_CONFIG_SECRET_NAME>': os.environ.get('DTRACK_APP_CONFIG_SECRET_NAME','dependency-track-app-config'),

            '<DTRACK_APISERVER_PV_ENABLED>': (os.environ.get('DTRACK_APISERVER_PV_ENABLED','false') or 'false').lower(),
            '<DTRACK_APISERVER_PV_CLASSNAME>': os.environ.get('DTRACK_APISERVER_PV_CLASSNAME',''),
            '<DTRACK_APISERVER_PV_SIZE>': os.environ.get('DTRACK_APISERVER_PV_SIZE','5Gi'),
          }

          ann_raw = os.environ.get('DTRACK_INGRESS_ANNOTATIONS_JSON','{}') or '{}'
          try:
            ann = json.loads(ann_raw)
            if not isinstance(ann, dict):
              raise ValueError('must be a JSON object')
          except Exception:
            ann = {}

          text = Path('helm/dependency-track/values.template.yaml').read_text(encoding='utf-8')
          for k, v in repl.items():
            text = text.replace(k, str(v))

          text = text.replace('<DTRACK_INGRESS_ANNOTATIONS_JSON>', json.dumps(ann, separators=(',',':')))

          out = Path(os.environ['RUNNER_TEMP']) / 'values.generated.yaml'
          out.write_text(text, encoding='utf-8')
          out.chmod(0o600)
          PY

          test -s "${RUNNER_TEMP}/values.generated.yaml"

      - name: Install/upgrade Dependency-Track (official chart; images pulled from registry)
        shell: bash
        run: |
          set -euo pipefail

          helm repo add dependency-track "${DTRACK_HELM_REPO_URL}"
          helm repo update

          helm upgrade --install "${DTRACK_RELEASE_NAME}" dependency-track/dependency-track \
            --namespace="${DTRACK_NAMESPACE}" \
            --version="${DTRACK_CHART_VERSION}" \
            --values="${RUNNER_TEMP}/values.generated.yaml" \
            --wait --atomic --timeout="${HELM_TIMEOUT}"

          kubectl --namespace="${DTRACK_NAMESPACE}" get pods --output=wide
          kubectl --namespace="${DTRACK_NAMESPACE}" get svc --output=wide

      - name: Post-deploy checks
        shell: bash
        run: |
          set -euo pipefail

          kubectl --namespace="${DTRACK_NAMESPACE}" get ingress -o wide || true
          kubectl --namespace="${DTRACK_NAMESPACE}" get svc -o wide

          kubectl --namespace="${DTRACK_NAMESPACE}" wait --for=condition=Ready pod \
            -l app.kubernetes.io/name=dependency-track-apiserver \
            --timeout=5m || true

          echo "Done."
