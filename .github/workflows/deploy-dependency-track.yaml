name: Deploy Dependency-Track (AKS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: GitHub Environment to use
        required: true
        type: choice
        options:
          - dev
          - preprod
          - prod

      debug:
        description: Enable debug mode (extra app logging + debug artefacts job)
        required: false
        type: boolean
        default: false

      use_admin_credentials:
        description: Use AKS admin kubeconfig (adds --admin to az aks get-credentials)
        required: false
        type: boolean
        default: false

      helm_timeout:
        description: Helm timeout (e.g. 15m, 600s, 1h)
        required: false
        type: string
        default: "15m"

concurrency:
  group: dependency-track-deploy-${{ inputs.environment }}
  cancel-in-progress: false

permissions:
  contents: read
  # Staged for advanced OIDC / Entra federation (optional). Not used in the baseline SP mode.
  id-token: write

jobs:
  deploy:
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 30

    env:
      # Keep Azure CLI state isolated and avoid cross-job contamination (initialised in the first step from RUNNER_TEMP).
      # Inputs
      HELM_TIMEOUT: ${{ inputs.helm_timeout }}
      DEBUG: ${{ inputs.debug }}

      # ----------------------------------------------------------------------
      # Vars-first fallback to secrets (no resolver script)
      # ----------------------------------------------------------------------

      # Azure / AKS (baseline auth: SP + secret)
      DEPLOY_CLIENT_ID: ${{ vars.DEPLOY_CLIENT_ID != '' && vars.DEPLOY_CLIENT_ID || secrets.DEPLOY_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID != '' && vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID != '' && vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_SECRET: ${{ vars.DEPLOY_SECRET != '' && vars.DEPLOY_SECRET || secrets.DEPLOY_SECRET }}
      AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP != '' && vars.AKS_RESOURCE_GROUP || secrets.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME != '' && vars.AKS_CLUSTER_NAME || secrets.AKS_CLUSTER_NAME }}

      # Container registry creds (Nexus)
      REGISTRY_SERVER: ${{ vars.REGISTRY_SERVER != '' && vars.REGISTRY_SERVER || secrets.REGISTRY_SERVER }}
      REGISTRY_USERNAME: ${{ vars.REGISTRY_USERNAME != '' && vars.REGISTRY_USERNAME || secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ vars.REGISTRY_PASSWORD != '' && vars.REGISTRY_PASSWORD || secrets.REGISTRY_PASSWORD }}

      # Wildcard TLS material
      ELOKO_WILDCARD_CRT: ${{ vars.ELOKO_WILDCARD_CRT != '' && vars.ELOKO_WILDCARD_CRT || secrets.ELOKO_WILDCARD_CRT }}
      ELOKO_WILDCARD_KEY: ${{ vars.ELOKO_WILDCARD_KEY != '' && vars.ELOKO_WILDCARD_KEY || secrets.ELOKO_WILDCARD_KEY }}

      # Database (external Postgres) - JDBC only (no URL conversion in this repo)
      ALPINE_DATABASE_MODE: ${{ (vars.ALPINE_DATABASE_MODE != '' && vars.ALPINE_DATABASE_MODE) || (secrets.ALPINE_DATABASE_MODE != '' && secrets.ALPINE_DATABASE_MODE) || 'external' }}
      ALPINE_DATABASE_URL: ${{ vars.ALPINE_DATABASE_URL != '' && vars.ALPINE_DATABASE_URL || secrets.ALPINE_DATABASE_URL }}
      ALPINE_DATABASE_USERNAME: ${{ vars.ALPINE_DATABASE_USERNAME != '' && vars.ALPINE_DATABASE_USERNAME || secrets.ALPINE_DATABASE_USERNAME }}
      ALPINE_DATABASE_PASSWORD: ${{ vars.ALPINE_DATABASE_PASSWORD != '' && vars.ALPINE_DATABASE_PASSWORD || secrets.ALPINE_DATABASE_PASSWORD }}
      # Required for Azure Flexible Server (and some Alpine/JDO configurations): explicit JDBC driver class
      # Prefer vars over secrets to minimise chance of leaking secrets via debugging output.
      # Supports legacy `DTRACK_ALPINE_DATABASE_DRIVER` for backward compatibility.
      ALPINE_DATABASE_DRIVER: ${{ (vars.ALPINE_DATABASE_DRIVER != '' && vars.ALPINE_DATABASE_DRIVER) || (vars.DTRACK_ALPINE_DATABASE_DRIVER != '' && vars.DTRACK_ALPINE_DATABASE_DRIVER) || (secrets.ALPINE_DATABASE_DRIVER != '' && secrets.ALPINE_DATABASE_DRIVER) || (secrets.DTRACK_ALPINE_DATABASE_DRIVER != '' && secrets.DTRACK_ALPINE_DATABASE_DRIVER) || 'org.postgresql.Driver' }}

      # Defaults (can be overridden via vars/secrets)
      DTRACK_NAMESPACE: ${{ (vars.DTRACK_NAMESPACE != '' && vars.DTRACK_NAMESPACE) || (secrets.DTRACK_NAMESPACE != '' && secrets.DTRACK_NAMESPACE) || 'dependency-track' }}
      DTRACK_RELEASE_NAME: ${{ (vars.DTRACK_RELEASE_NAME != '' && vars.DTRACK_RELEASE_NAME) || (secrets.DTRACK_RELEASE_NAME != '' && secrets.DTRACK_RELEASE_NAME) || 'dependency-track' }}
      DTRACK_INGRESS_HOST: ${{ (vars.DTRACK_INGRESS_HOST != '' && vars.DTRACK_INGRESS_HOST) || (secrets.DTRACK_INGRESS_HOST != '' && secrets.DTRACK_INGRESS_HOST) || 'dtrack.logiki.co.uk' }}
      DTRACK_INGRESS_CLASS_NAME: ${{ (vars.DTRACK_INGRESS_CLASS_NAME != '' && vars.DTRACK_INGRESS_CLASS_NAME) || (secrets.DTRACK_INGRESS_CLASS_NAME != '' && secrets.DTRACK_INGRESS_CLASS_NAME) || 'traefik' }}

      # Helm chart
      DTRACK_HELM_REPO_URL: ${{ (vars.DTRACK_HELM_REPO_URL != '' && vars.DTRACK_HELM_REPO_URL) || (secrets.DTRACK_HELM_REPO_URL != '' && secrets.DTRACK_HELM_REPO_URL) || 'https://dependencytrack.github.io/helm-charts' }}
      DTRACK_CHART_VERSION: ${{ (vars.DTRACK_CHART_VERSION != '' && vars.DTRACK_CHART_VERSION) || (secrets.DTRACK_CHART_VERSION != '' && secrets.DTRACK_CHART_VERSION) || '0.41.0' }}

      # K8s secret names
      IMAGE_PULL_SECRET_NAME: ${{ (vars.IMAGE_PULL_SECRET_NAME != '' && vars.IMAGE_PULL_SECRET_NAME) || (secrets.IMAGE_PULL_SECRET_NAME != '' && secrets.IMAGE_PULL_SECRET_NAME) || 'nexus-pull' }}
      INGRESS_TLS_SECRET_NAME: ${{ (vars.INGRESS_TLS_SECRET_NAME != '' && vars.INGRESS_TLS_SECRET_NAME) || (secrets.INGRESS_TLS_SECRET_NAME != '' && secrets.INGRESS_TLS_SECRET_NAME) || 'dtrack-wildcard-tls' }}
      DTRACK_APP_CONFIG_SECRET_NAME: ${{ (vars.DTRACK_APP_CONFIG_SECRET_NAME != '' && vars.DTRACK_APP_CONFIG_SECRET_NAME) || (secrets.DTRACK_APP_CONFIG_SECRET_NAME != '' && secrets.DTRACK_APP_CONFIG_SECRET_NAME) || 'dependency-track-app-config' }}
      DTRACK_SECRET_KEY_EXISTING_SECRET_NAME: ${{ (vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || (secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || 'dtrack-secret-key' }}

      # Mastered secret key material (base64) - REQUIRED
      DTRACK_SECRET_KEY: ${{ secrets.DTRACK_SECRET_KEY }}

      # Images (always pulled from REGISTRY_SERVER)
      DTRACK_APISERVER_IMAGE_REPOSITORY: ${{ (vars.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && vars.DTRACK_APISERVER_IMAGE_REPOSITORY) || (secrets.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && secrets.DTRACK_APISERVER_IMAGE_REPOSITORY) || 'dependencytrack/apiserver' }}
      DTRACK_FRONTEND_IMAGE_REPOSITORY: ${{ (vars.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && vars.DTRACK_FRONTEND_IMAGE_REPOSITORY) || (secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY) || 'dependencytrack/frontend' }}
      DTRACK_APISERVER_IMAGE_TAG: ${{ (vars.DTRACK_APISERVER_IMAGE_TAG != '' && vars.DTRACK_APISERVER_IMAGE_TAG) || (secrets.DTRACK_APISERVER_IMAGE_TAG != '' && secrets.DTRACK_APISERVER_IMAGE_TAG) || '' }}
      DTRACK_FRONTEND_IMAGE_TAG: ${{ (vars.DTRACK_FRONTEND_IMAGE_TAG != '' && vars.DTRACK_FRONTEND_IMAGE_TAG) || (secrets.DTRACK_FRONTEND_IMAGE_TAG != '' && secrets.DTRACK_FRONTEND_IMAGE_TAG) || '' }}

      # Optional
      DTRACK_FRONTEND_API_BASE_URL: ${{ (vars.DTRACK_FRONTEND_API_BASE_URL != '' && vars.DTRACK_FRONTEND_API_BASE_URL) || (secrets.DTRACK_FRONTEND_API_BASE_URL != '' && secrets.DTRACK_FRONTEND_API_BASE_URL) || '' }}
      DTRACK_INGRESS_ANNOTATIONS_JSON: ${{ (vars.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && vars.DTRACK_INGRESS_ANNOTATIONS_JSON) || (secrets.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && secrets.DTRACK_INGRESS_ANNOTATIONS_JSON) || '{}' }}

      # PV placeholders (explicit defaults)
      DTRACK_APISERVER_PV_ENABLED: ${{ (vars.DTRACK_APISERVER_PV_ENABLED != '' && vars.DTRACK_APISERVER_PV_ENABLED) || (secrets.DTRACK_APISERVER_PV_ENABLED != '' && secrets.DTRACK_APISERVER_PV_ENABLED) || 'false' }}
      DTRACK_APISERVER_PV_CLASSNAME: ${{ (vars.DTRACK_APISERVER_PV_CLASSNAME != '' && vars.DTRACK_APISERVER_PV_CLASSNAME) || (secrets.DTRACK_APISERVER_PV_CLASSNAME != '' && secrets.DTRACK_APISERVER_PV_CLASSNAME) || '' }}
      DTRACK_APISERVER_PV_SIZE: ${{ (vars.DTRACK_APISERVER_PV_SIZE != '' && vars.DTRACK_APISERVER_PV_SIZE) || (secrets.DTRACK_APISERVER_PV_SIZE != '' && secrets.DTRACK_APISERVER_PV_SIZE) || '5Gi' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Init runtime paths (AZURE_CONFIG_DIR, KUBECONFIG)
        shell: bash
        run: |
          set -euo pipefail
          umask 077
          mkdir -p "${RUNNER_TEMP}/.azure"
          echo "AZURE_CONFIG_DIR=${RUNNER_TEMP}/.azure" >> "${GITHUB_ENV}"
          echo "KUBECONFIG=${RUNNER_TEMP}/kubeconfig" >> "${GITHUB_ENV}"

      - name: Verify toolchain on runner
        shell: bash
        run: |
          set -euo pipefail
          command -v az >/dev/null
          command -v kubectl >/dev/null
          command -v helm >/dev/null
          command -v kubelogin >/dev/null
          command -v openssl >/dev/null
          az version
          kubectl version --client=true
          helm version

      - name: Echo resolved non-sensitive inputs
        shell: bash
        run: |
          set -euo pipefail
          echo "DEPLOY_CLIENT_ID=${DEPLOY_CLIENT_ID}"
          echo "AZURE_TENANT_ID=${AZURE_TENANT_ID}"
          echo "AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
          echo "AKS_RESOURCE_GROUP=${AKS_RESOURCE_GROUP}"
          echo "AKS_CLUSTER_NAME=${AKS_CLUSTER_NAME}"
          echo "REGISTRY_SERVER=${REGISTRY_SERVER}"
          echo "REGISTRY_USERNAME=${REGISTRY_USERNAME}"
          echo "IMAGE_PULL_SECRET_NAME=${IMAGE_PULL_SECRET_NAME}"
          echo "INGRESS_TLS_SECRET_NAME=${INGRESS_TLS_SECRET_NAME}"
          echo "DTRACK_NAMESPACE=${DTRACK_NAMESPACE}"
          echo "DTRACK_RELEASE_NAME=${DTRACK_RELEASE_NAME}"
          echo "DTRACK_INGRESS_HOST=${DTRACK_INGRESS_HOST}"
          echo "DTRACK_INGRESS_CLASS_NAME=${DTRACK_INGRESS_CLASS_NAME}"
          echo "DTRACK_HELM_REPO_URL=${DTRACK_HELM_REPO_URL}"
          echo "DTRACK_CHART_VERSION=${DTRACK_CHART_VERSION}"
          echo "DTRACK_APISERVER_IMAGE_REPOSITORY=${DTRACK_APISERVER_IMAGE_REPOSITORY}"
          echo "DTRACK_FRONTEND_IMAGE_REPOSITORY=${DTRACK_FRONTEND_IMAGE_REPOSITORY}"
          echo "ALPINE_DATABASE_MODE=${ALPINE_DATABASE_MODE}"
          if [[ -n "${ALPINE_DATABASE_URL:-}" && "${ALPINE_DATABASE_URL}" == jdbc:postgresql://* ]]; then
            echo "ALPINE_DATABASE_URL=${ALPINE_DATABASE_URL}"
          else
            echo "ALPINE_DATABASE_URL=<redacted>"
          fi
          echo "ALPINE_DATABASE_USERNAME=${ALPINE_DATABASE_USERNAME}"
          echo "ALPINE_DATABASE_PASSWORD=<redacted>"
          echo "DTRACK_SECRET_KEY_EXISTING_SECRET_NAME=${DTRACK_SECRET_KEY_EXISTING_SECRET_NAME}"

      - name: Validate required variables
        shell: bash
        run: |
          set -euo pipefail

          : "${DEPLOY_CLIENT_ID:?DEPLOY_CLIENT_ID empty}"
          : "${DEPLOY_SECRET:?DEPLOY_SECRET empty}"
          : "${AZURE_TENANT_ID:?AZURE_TENANT_ID empty}"
          : "${AZURE_SUBSCRIPTION_ID:?AZURE_SUBSCRIPTION_ID empty}"
          : "${AKS_RESOURCE_GROUP:?AKS_RESOURCE_GROUP empty}"
          : "${AKS_CLUSTER_NAME:?AKS_CLUSTER_NAME empty}"

          : "${REGISTRY_SERVER:?REGISTRY_SERVER empty}"
          : "${REGISTRY_USERNAME:?REGISTRY_USERNAME empty}"
          : "${REGISTRY_PASSWORD:?REGISTRY_PASSWORD empty}"
          : "${IMAGE_PULL_SECRET_NAME:?IMAGE_PULL_SECRET_NAME empty}"

          : "${INGRESS_TLS_SECRET_NAME:?INGRESS_TLS_SECRET_NAME empty}"
          : "${ELOKO_WILDCARD_CRT:?ELOKO_WILDCARD_CRT empty}"
          : "${ELOKO_WILDCARD_KEY:?ELOKO_WILDCARD_KEY empty}"

          : "${ALPINE_DATABASE_MODE:?ALPINE_DATABASE_MODE empty}"
          : "${ALPINE_DATABASE_URL:?ALPINE_DATABASE_URL empty}"
          : "${ALPINE_DATABASE_USERNAME:?ALPINE_DATABASE_USERNAME empty}"
          : "${ALPINE_DATABASE_PASSWORD:?ALPINE_DATABASE_PASSWORD empty}"

          if [[ "${ALPINE_DATABASE_URL}" != jdbc:postgresql://* ]]; then
            echo "ERROR: ALPINE_DATABASE_URL must be a JDBC URL starting with 'jdbc:postgresql://'." >&2
            echo "Example: jdbc:postgresql://psql.example.com:5432/dtrack?sslmode=require" >&2
            exit 1
          fi

          : "${DTRACK_SECRET_KEY_EXISTING_SECRET_NAME:?DTRACK_SECRET_KEY_EXISTING_SECRET_NAME empty}"
          : "${DTRACK_SECRET_KEY:?DTRACK_SECRET_KEY empty (must be a GitHub Environment Secret mastered from Key Vault)}"

          # Validate DTRACK_SECRET_KEY is base64 and decodes to >= 32 bytes.
          key_b64="$(echo -n "${DTRACK_SECRET_KEY}" | tr -d '\r\n ' )"
          if ! echo -n "${key_b64}" | base64 -d >/dev/null 2>&1; then
            echo "ERROR: DTRACK_SECRET_KEY is not valid base64." >&2
            exit 1
          fi
          key_len="$(echo -n "${key_b64}" | base64 -d 2>/dev/null | wc -c | tr -d ' ')"
          if [[ "${key_len}" -lt 32 ]]; then
            echo "ERROR: DTRACK_SECRET_KEY decodes to ${key_len} bytes; expected at least 32 bytes." >&2
            exit 1
          fi

          # Normalise Helm timeout
          if [[ "${HELM_TIMEOUT}" =~ ^[0-9]+$ ]]; then
            HELM_TIMEOUT="${HELM_TIMEOUT}m"
          fi
          if [[ ! "${HELM_TIMEOUT}" =~ ^[0-9]+[smh]$ ]]; then
            echo "ERROR: HELM_TIMEOUT must be like '10m', '600s', '5h' (or a number of minutes like '10'). Got: '${HELM_TIMEOUT}'" >&2
            exit 1
          fi
          echo "HELM_TIMEOUT=${HELM_TIMEOUT}" >> "${GITHUB_ENV}"

      - name: Azure login (Service Principal + secret)
        shell: bash
        run: |
          set -euo pipefail

          rm -rf "${AZURE_CONFIG_DIR}" 2>/dev/null || true
          mkdir -p "${AZURE_CONFIG_DIR}"
          az logout --output=none 2>/dev/null || true
          az account clear --output=none 2>/dev/null || true

          az login \
            --service-principal \
            --username="${DEPLOY_CLIENT_ID}" \
            --password="${DEPLOY_SECRET}" \
            --tenant="${AZURE_TENANT_ID}" \
            --output=none

          az account set --subscription="${AZURE_SUBSCRIPTION_ID}"

      - name: Get AKS credentials (Entra) + kubelogin convert
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ADMIN_FLAG=""
          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials \
            --resource-group="${AKS_RESOURCE_GROUP}" \
            --name="${AKS_CLUSTER_NAME}" \
            ${ADMIN_FLAG} \
            --file="${KUBECONFIG}" \
            --overwrite-existing

          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            echo "Using admin kubeconfig; skipping kubelogin convert."
            exit 0
          fi

          kubelogin convert-kubeconfig \
            --login="spn" \
            --client-id="${DEPLOY_CLIENT_ID}" \
            --client-secret="${DEPLOY_SECRET}" \
            --tenant-id="${AZURE_TENANT_ID}" \
            --kubeconfig="${KUBECONFIG}"

          if grep --quiet "command: azurecli" "${KUBECONFIG}"; then
            echo "ERROR: kubeconfig still references azurecli exec (interactive). kubelogin convert failed." >&2
            exit 1
          fi

      - name: Ensure namespace
        shell: bash
        run: |
          set -euo pipefail
          kubectl get namespace "${DTRACK_NAMESPACE}" >/dev/null 2>&1 || kubectl create namespace "${DTRACK_NAMESPACE}"

      - name: Ensure imagePullSecret (registry) in dependency-track namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret docker-registry "${IMAGE_PULL_SECRET_NAME}" \
            --docker-server="${REGISTRY_SERVER}" \
            --docker-username="${REGISTRY_USERNAME}" \
            --docker-password="${REGISTRY_PASSWORD}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Create/update TLS secret (wildcard) in dependency-track namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          CERT_FILE="${RUNNER_TEMP}/wildcard.crt"
          KEY_FILE="${RUNNER_TEMP}/wildcard.key"

          printf '%s' "${ELOKO_WILDCARD_CRT}" | tr -d '\r' > "${CERT_FILE}"
          printf '%s' "${ELOKO_WILDCARD_KEY}" | tr -d '\r' > "${KEY_FILE}"
          chmod 600 "${CERT_FILE}" "${KEY_FILE}"

          if ! grep -F -q -- "-----BEGIN CERTIFICATE-----" "${CERT_FILE}"; then
            echo "ERROR: ELOKO_WILDCARD_CRT does not look like PEM. Expected '-----BEGIN CERTIFICATE-----' header." >&2
            exit 1
          fi
          if ! grep -F -q -- "-----BEGIN" "${KEY_FILE}"; then
            echo "ERROR: ELOKO_WILDCARD_KEY does not look like PEM." >&2
            exit 1
          fi

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret tls "${INGRESS_TLS_SECRET_NAME}" \
            --cert="${CERT_FILE}" \
            --key="${KEY_FILE}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Ensure secret key secret (mastered in Key Vault; enforce no drift)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          SECRET_NAME="${DTRACK_SECRET_KEY_EXISTING_SECRET_NAME}"
          desired_b64="$(echo -n "${DTRACK_SECRET_KEY}" | tr -d '\r\n ' )"

          # Decode to a file so we can create the secret without ever embedding the base64 string in manifests.
          KEY_FILE="${RUNNER_TEMP}/dtrack.secret.key"
          echo -n "${desired_b64}" | base64 -d > "${KEY_FILE}"
          chmod 600 "${KEY_FILE}"

          # If secret exists, compare to mastered value (refuse rotation).
          if kubectl --namespace="${DTRACK_NAMESPACE}" get secret "${SECRET_NAME}" >/dev/null 2>&1; then
            existing_b64="$(kubectl --namespace="${DTRACK_NAMESPACE}" get secret "${SECRET_NAME}" -o jsonpath='{.data.secret\.key}' 2>/dev/null || true)"
            if [[ -z "${existing_b64}" ]]; then
              existing_b64="$(kubectl --namespace="${DTRACK_NAMESPACE}" get secret "${SECRET_NAME}" -o jsonpath='{.data.secretKey}' 2>/dev/null || true)"
            fi

            if [[ -z "${existing_b64}" ]]; then
              echo "ERROR: Secret '${SECRET_NAME}' exists but does not contain data key 'secret.key' or 'secretKey'." >&2
              echo "Remediation: recreate the secret with key 'secret.key' (file name) and re-run." >&2
              exit 1
            fi

            if [[ "${existing_b64}" != "${desired_b64}" ]]; then
              echo "ERROR: Secret-key drift detected for '${DTRACK_NAMESPACE}/${SECRET_NAME}'." >&2
              echo "The cluster secret key does not match the mastered value (Key Vault -> GHES secret DTRACK_SECRET_KEY)." >&2
              echo "This repo refuses to rotate the key automatically because it can invalidate encrypted data/tokens." >&2
              echo "" >&2
              echo "Remediation options:" >&2
              echo "A) Align mastering to runtime (recommended):" >&2
              echo "   1) Export the current cluster value (base64):" >&2
              echo "      kubectl -n ${DTRACK_NAMESPACE} get secret ${SECRET_NAME} -o jsonpath='{.data.secret\\.key}'" >&2
              echo "   2) Set that exact base64 string into Key Vault so it syncs to GitHub Environment secret DTRACK_SECRET_KEY." >&2
              echo "   3) Re-run the workflow." >&2
              echo "" >&2
              echo "B) Intentional rotation / forced redeploy (destructive):" >&2
              echo "   1) Update Key Vault secret DTRACK_SECRET_KEY to the new desired value." >&2
              echo "   2) Manually delete the in-cluster secret so the workflow can recreate it:" >&2
              echo "      kubectl -n ${DTRACK_NAMESPACE} delete secret ${SECRET_NAME}" >&2
              echo "   3) Re-run the workflow." >&2
              echo "   Note: if the application has persisted encrypted material tied to the old key, rotation may break access." >&2
              exit 1
            fi

            echo "Secret key matches mastered value: ${DTRACK_NAMESPACE}/${SECRET_NAME}"
          else
            echo "Secret key secret missing; creating from mastered DTRACK_SECRET_KEY: ${DTRACK_NAMESPACE}/${SECRET_NAME}"
            kubectl --namespace="${DTRACK_NAMESPACE}" create secret generic "${SECRET_NAME}" \
              --from-file=secret.key="${KEY_FILE}" \
              --from-file=secretKey="${KEY_FILE}" \
              --dry-run=client --output=yaml \
              | kubectl apply --filename=-
          fi

      - name: Create/update app config secret (dependency-track)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ENV_FILE="${RUNNER_TEMP}/dtrack.env"
          rm -f "${ENV_FILE}" || true
          : > "${ENV_FILE}"
          chmod 600 "${ENV_FILE}"

          # Write env file without echoing values to logs.
          printf 'ALPINE_DATABASE_MODE=%s\n' "${ALPINE_DATABASE_MODE}" >> "${ENV_FILE}"
          printf 'ALPINE_DATABASE_URL=%s\n' "${ALPINE_DATABASE_URL}" >> "${ENV_FILE}"
          printf 'ALPINE_DATABASE_USERNAME=%s\n' "${ALPINE_DATABASE_USERNAME}" >> "${ENV_FILE}"
          printf 'ALPINE_DATABASE_PASSWORD=%s\n' "${ALPINE_DATABASE_PASSWORD}" >> "${ENV_FILE}"
          printf 'ALPINE_DATABASE_DRIVER=%s\n' "${ALPINE_DATABASE_DRIVER}" >> "${ENV_FILE}"

          if [[ "${DEBUG}" == "true" ]]; then
            printf 'LOGGING_LEVEL=DEBUG\n' >> "${ENV_FILE}"
          fi

          kubectl --namespace="${DTRACK_NAMESPACE}" create secret generic "${DTRACK_APP_CONFIG_SECRET_NAME}" \
            --from-env-file="${ENV_FILE}" \
            --dry-run=client --output=yaml \
            | kubectl apply --filename=-

      - name: Render values.generated.yaml (safe to publish as debug artefact)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          # Generate from the template using simple placeholder replacement.
          # Only non-sensitive values are inserted.
          TEMPLATE="helm/dependency-track/values.template.yaml"
          OUT="${RUNNER_TEMP}/values.generated.yaml"

          # Use perl for robust multi-replace without shell-escaping issues.
          perl -pe 's/<REGISTRY_SERVER>/$ENV{REGISTRY_SERVER}/g;
                    s/<IMAGE_PULL_SECRET_NAME>/$ENV{IMAGE_PULL_SECRET_NAME}/g;
                    s/<DTRACK_SECRET_KEY_EXISTING_SECRET_NAME>/$ENV{DTRACK_SECRET_KEY_EXISTING_SECRET_NAME}/g;
                    s/<DTRACK_APISERVER_IMAGE_REPOSITORY>/$ENV{DTRACK_APISERVER_IMAGE_REPOSITORY}/g;
                    s/<DTRACK_APISERVER_IMAGE_TAG>/$ENV{DTRACK_APISERVER_IMAGE_TAG}/g;
                    s/<DTRACK_FRONTEND_IMAGE_REPOSITORY>/$ENV{DTRACK_FRONTEND_IMAGE_REPOSITORY}/g;
                    s/<DTRACK_FRONTEND_IMAGE_TAG>/$ENV{DTRACK_FRONTEND_IMAGE_TAG}/g;
                    s/<DTRACK_FRONTEND_API_BASE_URL>/$ENV{DTRACK_FRONTEND_API_BASE_URL}/g;
                    s/<DTRACK_INGRESS_HOST>/$ENV{DTRACK_INGRESS_HOST}/g;
                    s/<DTRACK_INGRESS_CLASS_NAME>/$ENV{DTRACK_INGRESS_CLASS_NAME}/g;
                    s/<INGRESS_TLS_SECRET_NAME>/$ENV{INGRESS_TLS_SECRET_NAME}/g;
                    s/<DTRACK_APP_CONFIG_SECRET_NAME>/$ENV{DTRACK_APP_CONFIG_SECRET_NAME}/g;
                    s/<DTRACK_APISERVER_PV_ENABLED>/$ENV{DTRACK_APISERVER_PV_ENABLED}/g;
                    s/<DTRACK_APISERVER_PV_CLASSNAME>/$ENV{DTRACK_APISERVER_PV_CLASSNAME}/g;
                    s/<DTRACK_APISERVER_PV_SIZE>/$ENV{DTRACK_APISERVER_PV_SIZE}/g;
                    s/<DTRACK_INGRESS_ANNOTATIONS_JSON>/$ENV{DTRACK_INGRESS_ANNOTATIONS_JSON}/g;' "${TEMPLATE}" > "${OUT}"

          chmod 600 "${OUT}"
          test -s "${OUT}"

      - name: Install/upgrade Dependency-Track (official chart)
        shell: bash
        run: |
          set -euo pipefail

          helm repo add dependency-track "${DTRACK_HELM_REPO_URL}"
          helm repo update

          EXTRA_HELM_FLAGS=""
          if [[ "${DEBUG}" == "true" ]]; then
            EXTRA_HELM_FLAGS="--debug"
          fi

          ATOMIC_FLAG="--atomic"
          if [[ "${DEBUG}" == "true" ]]; then
            # Helm --atomic will rollback/uninstall on failure, which can erase the very state we need
            # to capture in the debug-artifacts job. In debug mode, preserve failed resources.
            ATOMIC_FLAG=""
            echo "DEBUG=true: disabling Helm --atomic to preserve failed resources for artifact capture."
          fi

          helm upgrade --install "${DTRACK_RELEASE_NAME}" dependency-track/dependency-track \
            --namespace="${DTRACK_NAMESPACE}" \
            --version="${DTRACK_CHART_VERSION}" \
            --values="${RUNNER_TEMP}/values.generated.yaml" \
            --wait ${ATOMIC_FLAG} --timeout="${HELM_TIMEOUT}" \
            ${EXTRA_HELM_FLAGS}

          kubectl --namespace="${DTRACK_NAMESPACE}" get pods --output=wide
          kubectl --namespace="${DTRACK_NAMESPACE}" get svc --output=wide

      - name: Post-deploy checks
        shell: bash
        run: |
          set -euo pipefail
          kubectl --namespace="${DTRACK_NAMESPACE}" get ingress -o wide || true
          kubectl --namespace="${DTRACK_NAMESPACE}" get svc -o wide
          kubectl --namespace="${DTRACK_NAMESPACE}" wait --for=condition=Ready pod \
            -l app.kubernetes.io/component=api-server \
            --timeout=5m || true
          echo "Done."

  debug-artifacts:
    needs: [deploy]
    if: ${{ always() && inputs.debug }}
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 30

    env:
      HELM_TIMEOUT: ${{ inputs.helm_timeout }}

      USE_ADMIN_CREDENTIALS: ${{ inputs.use_admin_credentials }}

      # Minimal set of vars (same resolution contract)
      DEPLOY_CLIENT_ID: ${{ vars.DEPLOY_CLIENT_ID != '' && vars.DEPLOY_CLIENT_ID || secrets.DEPLOY_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID != '' && vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID != '' && vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_SECRET: ${{ vars.DEPLOY_SECRET != '' && vars.DEPLOY_SECRET || secrets.DEPLOY_SECRET }}
      AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP != '' && vars.AKS_RESOURCE_GROUP || secrets.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME != '' && vars.AKS_CLUSTER_NAME || secrets.AKS_CLUSTER_NAME }}

      REGISTRY_SERVER: ${{ vars.REGISTRY_SERVER != '' && vars.REGISTRY_SERVER || secrets.REGISTRY_SERVER }}
      IMAGE_PULL_SECRET_NAME: ${{ (vars.IMAGE_PULL_SECRET_NAME != '' && vars.IMAGE_PULL_SECRET_NAME) || (secrets.IMAGE_PULL_SECRET_NAME != '' && secrets.IMAGE_PULL_SECRET_NAME) || 'nexus-pull' }}

      DTRACK_NAMESPACE: ${{ (vars.DTRACK_NAMESPACE != '' && vars.DTRACK_NAMESPACE) || (secrets.DTRACK_NAMESPACE != '' && secrets.DTRACK_NAMESPACE) || 'dependency-track' }}
      DTRACK_RELEASE_NAME: ${{ (vars.DTRACK_RELEASE_NAME != '' && vars.DTRACK_RELEASE_NAME) || (secrets.DTRACK_RELEASE_NAME != '' && secrets.DTRACK_RELEASE_NAME) || 'dependency-track' }}
      DTRACK_HELM_REPO_URL: ${{ (vars.DTRACK_HELM_REPO_URL != '' && vars.DTRACK_HELM_REPO_URL) || (secrets.DTRACK_HELM_REPO_URL != '' && secrets.DTRACK_HELM_REPO_URL) || 'https://dependencytrack.github.io/helm-charts' }}
      DTRACK_CHART_VERSION: ${{ (vars.DTRACK_CHART_VERSION != '' && vars.DTRACK_CHART_VERSION) || (secrets.DTRACK_CHART_VERSION != '' && secrets.DTRACK_CHART_VERSION) || '0.41.0' }}

      DTRACK_INGRESS_HOST: ${{ (vars.DTRACK_INGRESS_HOST != '' && vars.DTRACK_INGRESS_HOST) || (secrets.DTRACK_INGRESS_HOST != '' && secrets.DTRACK_INGRESS_HOST) || 'dtrack.logiki.co.uk' }}
      DTRACK_INGRESS_CLASS_NAME: ${{ (vars.DTRACK_INGRESS_CLASS_NAME != '' && vars.DTRACK_INGRESS_CLASS_NAME) || (secrets.DTRACK_INGRESS_CLASS_NAME != '' && secrets.DTRACK_INGRESS_CLASS_NAME) || 'traefik' }}
      INGRESS_TLS_SECRET_NAME: ${{ (vars.INGRESS_TLS_SECRET_NAME != '' && vars.INGRESS_TLS_SECRET_NAME) || (secrets.INGRESS_TLS_SECRET_NAME != '' && secrets.INGRESS_TLS_SECRET_NAME) || 'dtrack-wildcard-tls' }}

      DTRACK_APP_CONFIG_SECRET_NAME: ${{ (vars.DTRACK_APP_CONFIG_SECRET_NAME != '' && vars.DTRACK_APP_CONFIG_SECRET_NAME) || (secrets.DTRACK_APP_CONFIG_SECRET_NAME != '' && secrets.DTRACK_APP_CONFIG_SECRET_NAME) || 'dependency-track-app-config' }}
      DTRACK_SECRET_KEY_EXISTING_SECRET_NAME: ${{ (vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && vars.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || (secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME != '' && secrets.DTRACK_SECRET_KEY_EXISTING_SECRET_NAME) || 'dtrack-secret-key' }}

      DTRACK_APISERVER_IMAGE_REPOSITORY: ${{ (vars.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && vars.DTRACK_APISERVER_IMAGE_REPOSITORY) || (secrets.DTRACK_APISERVER_IMAGE_REPOSITORY != '' && secrets.DTRACK_APISERVER_IMAGE_REPOSITORY) || 'dependencytrack/apiserver' }}
      DTRACK_FRONTEND_IMAGE_REPOSITORY: ${{ (vars.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && vars.DTRACK_FRONTEND_IMAGE_REPOSITORY) || (secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY != '' && secrets.DTRACK_FRONTEND_IMAGE_REPOSITORY) || 'dependencytrack/frontend' }}
      DTRACK_APISERVER_IMAGE_TAG: ${{ (vars.DTRACK_APISERVER_IMAGE_TAG != '' && vars.DTRACK_APISERVER_IMAGE_TAG) || (secrets.DTRACK_APISERVER_IMAGE_TAG != '' && secrets.DTRACK_APISERVER_IMAGE_TAG) || '' }}
      DTRACK_FRONTEND_IMAGE_TAG: ${{ (vars.DTRACK_FRONTEND_IMAGE_TAG != '' && vars.DTRACK_FRONTEND_IMAGE_TAG) || (secrets.DTRACK_FRONTEND_IMAGE_TAG != '' && secrets.DTRACK_FRONTEND_IMAGE_TAG) || '' }}
      DTRACK_FRONTEND_API_BASE_URL: ${{ (vars.DTRACK_FRONTEND_API_BASE_URL != '' && vars.DTRACK_FRONTEND_API_BASE_URL) || (secrets.DTRACK_FRONTEND_API_BASE_URL != '' && secrets.DTRACK_FRONTEND_API_BASE_URL) || '' }}
      DTRACK_INGRESS_ANNOTATIONS_JSON: ${{ (vars.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && vars.DTRACK_INGRESS_ANNOTATIONS_JSON) || (secrets.DTRACK_INGRESS_ANNOTATIONS_JSON != '' && secrets.DTRACK_INGRESS_ANNOTATIONS_JSON) || '{}' }}

      DTRACK_APISERVER_PV_ENABLED: ${{ (vars.DTRACK_APISERVER_PV_ENABLED != '' && vars.DTRACK_APISERVER_PV_ENABLED) || (secrets.DTRACK_APISERVER_PV_ENABLED != '' && secrets.DTRACK_APISERVER_PV_ENABLED) || 'false' }}
      DTRACK_APISERVER_PV_CLASSNAME: ${{ (vars.DTRACK_APISERVER_PV_CLASSNAME != '' && vars.DTRACK_APISERVER_PV_CLASSNAME) || (secrets.DTRACK_APISERVER_PV_CLASSNAME != '' && secrets.DTRACK_APISERVER_PV_CLASSNAME) || '' }}
      DTRACK_APISERVER_PV_SIZE: ${{ (vars.DTRACK_APISERVER_PV_SIZE != '' && vars.DTRACK_APISERVER_PV_SIZE) || (secrets.DTRACK_APISERVER_PV_SIZE != '' && secrets.DTRACK_APISERVER_PV_SIZE) || '5Gi' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Init runtime paths (AZURE_CONFIG_DIR, KUBECONFIG)
        shell: bash
        run: |
          set -euo pipefail
          umask 077
          mkdir -p "${RUNNER_TEMP}/.azure"
          echo "AZURE_CONFIG_DIR=${RUNNER_TEMP}/.azure" >> "${GITHUB_ENV}"
          echo "KUBECONFIG=${RUNNER_TEMP}/kubeconfig" >> "${GITHUB_ENV}"

      - name: Azure login (Service Principal + secret)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "${AZURE_CONFIG_DIR}" 2>/dev/null || true
          mkdir -p "${AZURE_CONFIG_DIR}"
          az logout --output=none 2>/dev/null || true
          az account clear --output=none 2>/dev/null || true

          az login \
            --service-principal \
            --username="${DEPLOY_CLIENT_ID}" \
            --password="${DEPLOY_SECRET}" \
            --tenant="${AZURE_TENANT_ID}" \
            --output=none

          az account set --subscription="${AZURE_SUBSCRIPTION_ID}"

      - name: Get AKS credentials (Entra) + kubelogin convert
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ADMIN_FLAG=""
          if [[ "${USE_ADMIN_CREDENTIALS}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials \
            --resource-group="${AKS_RESOURCE_GROUP}" \
            --name="${AKS_CLUSTER_NAME}" \
            --file="${KUBECONFIG}" \
            ${ADMIN_FLAG} \
            --overwrite-existing

          kubelogin convert-kubeconfig \
            --login="spn" \
            --client-id="${DEPLOY_CLIENT_ID}" \
            --client-secret="${DEPLOY_SECRET}" \
            --tenant-id="${AZURE_TENANT_ID}" \
            --kubeconfig="${KUBECONFIG}"

      - name: Render values.generated.yaml (debug artefact)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          TEMPLATE="helm/dependency-track/values.template.yaml"
          OUT="${RUNNER_TEMP}/values.generated.yaml"

          perl -pe 's/<REGISTRY_SERVER>/$ENV{REGISTRY_SERVER}/g;
                    s/<IMAGE_PULL_SECRET_NAME>/$ENV{IMAGE_PULL_SECRET_NAME}/g;
                    s/<DTRACK_SECRET_KEY_EXISTING_SECRET_NAME>/$ENV{DTRACK_SECRET_KEY_EXISTING_SECRET_NAME}/g;
                    s/<DTRACK_APISERVER_IMAGE_REPOSITORY>/$ENV{DTRACK_APISERVER_IMAGE_REPOSITORY}/g;
                    s/<DTRACK_APISERVER_IMAGE_TAG>/$ENV{DTRACK_APISERVER_IMAGE_TAG}/g;
                    s/<DTRACK_FRONTEND_IMAGE_REPOSITORY>/$ENV{DTRACK_FRONTEND_IMAGE_REPOSITORY}/g;
                    s/<DTRACK_FRONTEND_IMAGE_TAG>/$ENV{DTRACK_FRONTEND_IMAGE_TAG}/g;
                    s/<DTRACK_FRONTEND_API_BASE_URL>/$ENV{DTRACK_FRONTEND_API_BASE_URL}/g;
                    s/<DTRACK_INGRESS_HOST>/$ENV{DTRACK_INGRESS_HOST}/g;
                    s/<DTRACK_INGRESS_CLASS_NAME>/$ENV{DTRACK_INGRESS_CLASS_NAME}/g;
                    s/<INGRESS_TLS_SECRET_NAME>/$ENV{INGRESS_TLS_SECRET_NAME}/g;
                    s/<DTRACK_APP_CONFIG_SECRET_NAME>/$ENV{DTRACK_APP_CONFIG_SECRET_NAME}/g;
                    s/<DTRACK_APISERVER_PV_ENABLED>/$ENV{DTRACK_APISERVER_PV_ENABLED}/g;
                    s/<DTRACK_APISERVER_PV_CLASSNAME>/$ENV{DTRACK_APISERVER_PV_CLASSNAME}/g;
                    s/<DTRACK_APISERVER_PV_SIZE>/$ENV{DTRACK_APISERVER_PV_SIZE}/g;
                    s/<DTRACK_INGRESS_ANNOTATIONS_JSON>/$ENV{DTRACK_INGRESS_ANNOTATIONS_JSON}/g;' "${TEMPLATE}" > "${OUT}"

          chmod 600 "${OUT}"

      - name: Collect diagnostics (best effort)
        shell: bash
        run: |
          set -euo pipefail
          DEBUG_DIR="${GITHUB_WORKSPACE}/debug"
          mkdir -p "${DEBUG_DIR}"

          cp -f "${RUNNER_TEMP}/values.generated.yaml" "${DEBUG_DIR}/values.generated.yaml"

          {
            echo "== Helm status ==";
            helm -n "${DTRACK_NAMESPACE}" status "${DTRACK_RELEASE_NAME}" || true;
            echo;
            echo "== Helm values ==";
            helm -n "${DTRACK_NAMESPACE}" get values "${DTRACK_RELEASE_NAME}" || true;
          } > "${DEBUG_DIR}/helm.txt" 2>&1

          kubectl -n "${DTRACK_NAMESPACE}" get pods -o wide > "${DEBUG_DIR}/pods.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" get svc -o wide > "${DEBUG_DIR}/svc.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" get ingress -o wide > "${DEBUG_DIR}/ingress.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" get statefulset -o wide > "${DEBUG_DIR}/statefulset.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" get deploy -o wide > "${DEBUG_DIR}/deploy.txt" 2>&1 || true

          kubectl -n "${DTRACK_NAMESPACE}" get events --sort-by=.lastTimestamp > "${DEBUG_DIR}/events.txt" 2>&1 || true

          kubectl -n "${DTRACK_NAMESPACE}" describe pod -l app.kubernetes.io/component=api-server > "${DEBUG_DIR}/describe-api-server.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" logs -l app.kubernetes.io/component=api-server --all-containers=true --tail=300 > "${DEBUG_DIR}/logs-api-server.txt" 2>&1 || true
          kubectl -n "${DTRACK_NAMESPACE}" logs -l app.kubernetes.io/component=api-server --all-containers=true --tail=300 --previous > "${DEBUG_DIR}/logs-api-server-previous.txt" 2>&1 || true

      - name: Upload debug artefacts
        uses: actions/upload-artifact@v3
        with:
          name: dependency-track-debug-${{ inputs.environment }}-${{ github.run_id }}
          path: debug
          if-no-files-found: warn